{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@tynik/web-workers/webpack/bootstrap","webpack://@tynik/web-workers/webpack/runtime/define property getters","webpack://@tynik/web-workers/webpack/runtime/global","webpack://@tynik/web-workers/webpack/runtime/hasOwnProperty shorthand","webpack://@tynik/web-workers/webpack/runtime/make namespace object","webpack://@tynik/web-workers/webpack/runtime/publicPath","webpack://@tynik/web-workers/./src/types.ts","webpack://@tynik/web-workers/./src/worker.ts","webpack://@tynik/web-workers/./src/events.ts","webpack://@tynik/web-workers/./src/utils/string.ts","webpack://@tynik/web-workers/./src/utils/transfer.ts","webpack://@tynik/web-workers/./src/errors.ts","webpack://@tynik/web-workers/./src/utils/function.ts","webpack://@tynik/web-workers/./src/task.ts","webpack://@tynik/web-workers/external commonjs \"react\"","webpack://@tynik/web-workers/./src/hooks/useTask.ts","webpack://@tynik/web-workers/./src/hooks/useBrainJsTask.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","import { EventCallback, EventAPI } from './events';\n\n// <--------- THESE TYPES ARE DUPLICATED WITH worker-loader.d.ts --------->\nexport type TaskRunId = string\n\nexport type FuncTaskMessage = {\n  func: string\n  args: any[]\n  deps: string[]\n}\n\nexport type GeneratorNextTaskMessage = {\n  next: boolean\n  args: any[]\n}\n\nexport type GeneratorReturnTaskMessage = {\n  return: boolean\n  args: [any]\n}\n\nexport type GeneratorThrowTaskMessage = {\n  throw: boolean\n  args: [any]\n}\n\nexport type TaskMessage = FuncTaskMessage\n  | GeneratorNextTaskMessage\n  | GeneratorReturnTaskMessage\n  | GeneratorThrowTaskMessage\n\nexport type TaskReplyMessage<Result = any, EventsList extends string = any> = {\n  taskRunId: TaskRunId\n  eventName: EventsList\n  result: Result\n  tookTime?: number\n}\n// </--------- THESE TYPES ARE DUPLICATED WITH worker-loader.d.ts --------->\n\nexport type FuncId = string;\n\nexport type TaskFunction = Function\n  | GeneratorFunction\n  | AsyncGeneratorFunction;\n\nexport type TaskFunctionResult = Generator | any\n\nexport type TaskFunctionsCache = Record<FuncId, TaskFunction>\n\nexport enum TaskEvent {\n  SENT = 'sent',\n  STARTED = 'started',\n  COMPLETED = 'completed',\n  NEXT = 'next',\n  ERROR = 'error'\n}\n\nexport type Meta = {\n  taskRunId: TaskRunId\n  queueLength: number\n  tookTime?: number\n}\n\nexport type TaskOptions = {\n  deps?: string[];\n}\n\nexport interface RunTaskAPI<Params extends any[], Result = any, EventsList extends string = any> {\n  whenSent: Promise<Meta>;\n  whenStarted: Promise<Meta>;\n  whenCompleted: Promise<{ result: Result } & Meta>;\n  whenError: Promise<{ result: string } & Meta>;\n  next: (...args: Params) => Promise<{ result: Result } & Meta>;\n  return: (value?: any) => void;\n  throw: (e?: any) => void;\n}\n\nexport interface TaskFuncContext<Result = any, EventsList extends string = any> {\n  reply: (eventName: string | TaskEvent, result: Result) => void;\n}\n\ninterface TaskWorkerI {\n  postMessage(message: TaskReplyMessage, transfer: Transferable[]): void;\n\n  postMessage(message: TaskReplyMessage, options?: StructuredSerializeOptions): void;\n}\n\nexport type TaskMessageEventData = {\n  taskRunId: TaskRunId\n} & (\n  FuncTaskMessage\n  & GeneratorNextTaskMessage\n  & GeneratorReturnTaskMessage\n  & GeneratorThrowTaskMessage\n);\n\nexport class TaskWorker extends Worker implements TaskWorkerI {\n  onmessage: ((this: TaskWorker, ev: MessageEvent<TaskMessageEventData>) => any) | null;\n  onmessageerror: ((this: TaskWorker, ev: MessageEvent<TaskMessageEventData>) => any) | null;\n}\n","export default function Worker_fn() {\n  return new Worker(__webpack_public_path__ + \"worker.worker.js\");\n}\n","export type EventCallback<Result = any> = (result?: Result) => void | boolean\n\nexport type Event<Result = any> = {\n  id: string\n  callback: EventCallback<Result>\n  once: boolean\n};\n\nexport type EventsList<List extends string> =\n  Partial<Record<List, Event<any>[]>>\n\nexport interface EventAPI {\n  remove: () => void;\n}\n\nexport class Events<Events extends string = any> {\n  private list: EventsList<Events> = {};\n\n  add<Result = any>(name: string, callback: EventCallback<Result>, once: boolean = false): EventAPI {\n    if (!this.list[name]) {\n      this.list[name] = [];\n    }\n    // set event id to remove event after when needed\n    const id = this.list[name].length;\n    // multiple callbacks for one event\n    this.list[name].push({ id, callback, once });\n\n    return {\n      remove: () => {\n        this.removeById(name, id);\n      }\n    };\n  }\n\n  raise<Result = any>(name: string, result?: Result): void {\n    (\n      this.list[name] || []\n    ).reduceRight((_, { id, callback, once }) => {\n      let remove;\n      try {\n        remove = callback(result);\n      } finally {\n        if (remove !== false && once) {\n          this.removeById(name, id);\n        }\n      }\n    }, []);\n  }\n\n  get count(): number {\n    return Object.keys(this.list).length;\n  }\n\n  getCountCallbacks(name: string): number {\n    return this.list[name]?.length || 0;\n  }\n\n  remove(name: string): void {\n    delete this.list[name];\n  }\n\n  clear(): void {\n    this.list = {};\n  }\n\n  private removeById(name: string, id: string): void {\n    const indexToRemove = this.list[name].findIndex(event => event.id === id);\n    this.list[name].splice(indexToRemove, 1);\n  }\n}\n","export const genId = (length: number = 9): string =>\n  Math.random().toString(36).substr(2, length);\n\nexport const getStrHash = (str: string): number => {\n  let hash;\n  for (let i = 0; i < str.length; i++) {\n    hash = Math.imul(31, hash) + str.charCodeAt(i) | 0;\n  }\n  return hash;\n};\n\nexport const findNextChar = (str: string, skipChars: string[], from: number = 0): {\n  char: string\n  index: number\n} => {\n  for (let i = from + 1; i < str.length; i++) {\n    if (skipChars.includes(str[i])) {\n      continue;\n    }\n    return {\n      char: str[i],\n      index: i\n    };\n  }\n  return {\n    char: null,\n    index: null\n  };\n};\n","import { TaskFunction } from '../types';\nimport { isFunction } from './function';\n\nexport enum DenormalizedObjectType {\n  FUNCTION = 'f'\n}\n\nexport const CLONEABLE_OBJECTS = [\n  Date,\n  RegExp,\n  Blob,\n  File,\n  FileList\n  // ArrayBuffer,\n  // Int8Array,\n  // Uint8Array,\n  // Uint8ClampedArray,\n  // Int16Array,\n  // Uint16Array,\n  // Int32Array,\n  // Uint32Array,\n  // Float32Array,\n  // Float64Array,\n  // DataView\n  // ImageBitmap,\n  // ImageData,\n  // Map,\n  // Set\n];\n\nexport const ifCloneableObject = (obj: any) =>\n  obj === null\n  || CLONEABLE_OBJECTS.some(objClass =>\n    typeof obj === 'number'\n    || typeof obj === 'string'\n    || typeof obj === 'boolean'\n    || obj instanceof objClass\n  );\n\nexport const denormalizePostMessageData = (data: any): any => {\n  if (isFunction(data)) {\n    return [DenormalizedObjectType.FUNCTION, String(data)];\n  }\n\n  if (ifCloneableObject(data)) {\n    return [null, data];\n  }\n\n  if (Array.isArray(data)) {\n    return [\n      null,\n      data.map(item => denormalizePostMessageData(item))\n    ];\n  }\n\n  return [\n    null,\n    Object.keys(data).reduce(\n      (result, key) => {\n        result[key] = denormalizePostMessageData(data[key]);\n        return result;\n      }, {})\n  ];\n};\n\nexport const normalizePostMessageData = (\n  args: any[],\n  normalizeFuncHandler: (obj: string) => TaskFunction\n): any => {\n  if (args.length < 2) {\n    return [];\n  }\n  const [primitiveType, obj] = args;\n\n  if (primitiveType === DenormalizedObjectType.FUNCTION) {\n    return normalizeFuncHandler(obj);\n  }\n\n  if (ifCloneableObject(obj)) {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map(item => normalizePostMessageData(item, normalizeFuncHandler));\n  }\n\n  return Object.keys(obj).reduce((result, key) => {\n    result[key] = normalizePostMessageData(obj[key], normalizeFuncHandler);\n    return result;\n  }, {});\n};\n","\nexport class NextIterationError extends Error {}\n\nexport class FuncSyntaxError extends SyntaxError {\n  constructor() {\n    super('The function syntax is erred');\n  }\n}\n","import {\n  FuncId,\n  TaskFunction,\n  TaskFunctionsCache\n} from '../types';\nimport { FuncSyntaxError } from '../errors';\nimport { getStrHash, findNextChar } from './string';\n\nexport const isFunction = (obj: any): boolean => typeof obj === 'function';\n\nexport const isGeneratorFunc = (func: TaskFunction): boolean =>\n  func.constructor.name === 'GeneratorFunction';\n\nexport const createGeneratorFuncFromStr = (args: string, funcCode: string): GeneratorFunction => {\n  const cls = Object.getPrototypeOf(function* () {}).constructor;\n  return cls(args, funcCode);\n};\n\nexport const generateTaskFuncId = (funcCode: string): FuncId =>\n  getStrHash(funcCode).toString();\n\nexport const getFuncArgsFromStr = (funcCode: string): {\n  args: string\n  isGenerator: boolean\n} => {\n  const startFuncArgsFrom = funcCode.indexOf('(') + 1;\n  if (!startFuncArgsFrom) {\n    throw new FuncSyntaxError();\n  }\n  const endFuncArgs = funcCode.indexOf(')', startFuncArgsFrom);\n  if (endFuncArgs === -1) {\n    throw new FuncSyntaxError();\n  }\n  let isGenerator = false;\n  const generatorMark = funcCode.indexOf('*');\n  if (generatorMark !== -1) {\n    isGenerator = generatorMark < startFuncArgsFrom;\n  }\n\n  return {\n    isGenerator,\n    args: funcCode.substring(startFuncArgsFrom, endFuncArgs)\n  };\n};\n\nexport const getFuncBodyFromStr = (funcCode: string): string => {\n  funcCode = funcCode.trim();\n\n  let funcBodyStart;\n  let funcBodyEnd;\n  let isInlineArrowFunc = false;\n\n  const isTraditionalFunc = funcCode.indexOf('function');\n  if (!isTraditionalFunc) {\n    funcBodyStart = funcCode.indexOf('{', isTraditionalFunc) + 1;\n    if (!funcBodyStart) {\n      throw new FuncSyntaxError();\n    }\n    funcBodyEnd = funcCode.lastIndexOf('}');\n\n  } else {\n    // arrow function\n    funcBodyStart = funcCode.indexOf('=>') + 2;\n\n    const isInlineArrowFuncWithObjReturning = findNextChar(funcCode, [' '], funcBodyStart);\n    // try to find \"(\" as the first char after \"=>\" to know that a function with object returning\n    if (isInlineArrowFuncWithObjReturning.char === '(') {\n      isInlineArrowFunc = true;\n      funcBodyStart = isInlineArrowFuncWithObjReturning.index + 1;\n      funcBodyEnd = funcCode.lastIndexOf(')');\n\n    } else {\n      let nextChar = findNextChar(funcCode, [' '], funcBodyStart);\n      if (nextChar.char === '{') {\n        funcBodyStart = nextChar.index + 1;\n        funcBodyEnd = funcCode.lastIndexOf('}');\n      } else {\n        isInlineArrowFunc = true;\n        funcBodyEnd = funcCode.length;\n      }\n    }\n  }\n\n  let body = funcCode.substring(funcBodyStart, funcBodyEnd).trim();\n\n  if (isInlineArrowFunc && body) {\n    body = ` return ${body}`;\n  }\n  return body;\n};\n\nexport type CreateFuncFromStrOptions = {\n  cache?: TaskFunctionsCache\n}\n\nexport const createFuncFromStr = (\n  funcCode: string,\n  { cache }: CreateFuncFromStrOptions = { cache: null }\n): TaskFunction => {\n\n  let taskFuncId = generateTaskFuncId(funcCode);\n  if (cache && cache[taskFuncId]) {\n    return cache[taskFuncId];\n  }\n  const {\n    args: funcArgs,\n    isGenerator: isGeneratorFunc\n  } = getFuncArgsFromStr(funcCode);\n\n  const funcBody = getFuncBodyFromStr(funcCode);\n\n  const func: TaskFunction = isGeneratorFunc\n    ? createGeneratorFuncFromStr(funcArgs, funcBody)\n    : new Function(funcArgs, funcBody);\n\n  if (cache) {\n    cache[taskFuncId] = func;\n  }\n  return func;\n};\n","import Worker from 'worker-loader!./worker';\nimport {\n  TaskRunId,\n  RunTaskAPI,\n  TaskEvent,\n  TaskFunction,\n  TaskOptions,\n  Meta,\n  TaskMessage,\n  FuncTaskMessage,\n  GeneratorNextTaskMessage,\n  GeneratorReturnTaskMessage,\n  GeneratorThrowTaskMessage\n} from './types';\nimport { EventCallback, Events } from './events';\nimport { denormalizePostMessageData, genId } from './utils';\n\nexport class Task<Params extends any[], Result = any, EventsList extends string = any> {\n  private readonly func: TaskFunction;\n  private readonly deps: string[];\n  private readonly events: Events<EventsList>;\n\n  private worker: Worker;\n  private stopped: boolean;\n  private queueLength: number;\n\n  constructor(\n    func: TaskFunction,\n    {\n      deps = []\n    }: TaskOptions = {}\n  ) {\n    this.func = func;\n    this.deps = deps;\n\n    this.events = new Events();\n\n    this.init();\n  }\n\n  whenEvent(eventName: string, callback: EventCallback<{ result: Result } & Meta>, once = false) {\n    return this.events.add(eventName, callback, once);\n  }\n\n  whenNext(callback: EventCallback<{ result: Result } & Meta>, once = false) {\n    return this.events.add(TaskEvent.NEXT, callback, once);\n  }\n\n  run(...args: Params): RunTaskAPI<Params, Result, EventsList> {\n    if (this.stopped) {\n      // re-init if stopped by timer or another action\n      this.init();\n    }\n    const taskRunId: TaskRunId = genId();\n\n    this.sendMsgToWorker<FuncTaskMessage>(taskRunId, {\n      func: String(this.func),\n      args: denormalizePostMessageData(args),\n      deps: this.deps\n    });\n\n    const ctx = this;\n    return {\n      get whenSent() {\n        return ctx.whenRunEvent(TaskEvent.SENT, taskRunId);\n      },\n      get whenStarted() {\n        return ctx.whenRunEvent(TaskEvent.STARTED, taskRunId);\n      },\n      get whenCompleted() {\n        return ctx.whenRunEvent(TaskEvent.COMPLETED, taskRunId);\n      },\n      get whenError() {\n        return ctx.whenRunEvent(TaskEvent.ERROR, taskRunId);\n      },\n      next: (...args) => {\n        const taskRunId: TaskRunId = genId();\n\n        this.sendMsgToWorker<GeneratorNextTaskMessage>(taskRunId, {\n          next: true,\n          // only for run method the arguments should be denormalized\n          args\n        });\n\n        return this.whenRunEvent(TaskEvent.NEXT, taskRunId);\n      },\n      return: (value) => {\n        const taskRunId: TaskRunId = genId();\n\n        this.sendMsgToWorker<GeneratorReturnTaskMessage>(taskRunId, {\n          return: true,\n          // only for run method the arguments should be denormalized\n          args: [value]\n        });\n      },\n      throw: (e) => {\n        const taskRunId: TaskRunId = genId();\n\n        this.sendMsgToWorker<GeneratorThrowTaskMessage>(taskRunId, {\n          throw: true,\n          // only for run method the arguments should be denormalized\n          args: [e]\n        });\n      }\n    };\n  };\n\n  stop() {\n    this.worker.terminate();\n    this.stopped = true;\n    this.queueLength = 0;\n  }\n\n  private init() {\n    this.queueLength = 0;\n    this.stopped = false;\n\n    this.worker = new Worker<Result, EventsList>();\n    this.worker.onmessage = (message) => {\n      const { data: { taskRunId, eventName, result, tookTime } } = message;\n\n      if ([TaskEvent.COMPLETED, TaskEvent.NEXT, TaskEvent.ERROR].includes(eventName)) {\n        this.queueLength--;\n      }\n\n      this.raiseEvent<Result>(eventName, taskRunId, {\n        result,\n        tookTime\n      });\n    };\n  }\n\n  private addEvent<Result = any, EventResult extends { result: Result } & Meta = any>(\n    eventName: string,\n    taskRunId: TaskRunId,\n    callback: EventCallback<EventResult>\n  ) {\n    return this.events.add<EventResult>(\n      eventName,\n      (result) => {\n        if (result.taskRunId !== taskRunId) {\n          // should not remove event callback\n          return false;\n        }\n        callback(result);\n      },\n      true\n    );\n  }\n\n  /**\n   * Wrapper for adding events, but only execute a callback for a specific task run id.\n   * Also, has two return interfaces: Event or Promise based.\n   * If a callback is passed event-based return applied.\n   */\n  private whenRunEvent<Result = any, EventResult extends { result: Result } & Meta = any>(\n    eventName: string,\n    taskRunId: TaskRunId\n  ) {\n    return new Promise<EventResult>((\n      (resolve, reject) => {\n        this.addEvent<Result>(eventName, taskRunId, resolve);\n        this.addEvent(TaskEvent.ERROR, taskRunId, reject);\n      }\n    ));\n  };\n\n  private raiseEvent<Result = any, EventResult = { result?: Result }>(\n    eventName: string,\n    taskRunId: TaskRunId,\n    // can accept meta fields besides taskRunId and queueLength\n    result?: EventResult & Omit<Meta, 'taskRunId' | 'queueLength'>\n  ) {\n    this.events.raise<EventResult & Meta>(eventName, {\n      taskRunId,\n      queueLength: this.queueLength,\n      ...result\n    });\n  }\n\n  private sendMsgToWorker<Message extends TaskMessage>(\n    taskRunId: TaskRunId,\n    message: Message\n  ) {\n    queueMicrotask(() => {\n      this.queueLength++;\n\n      // each message to worker should have taskRunId to know which event should be called after\n      this.worker.postMessage({\n        taskRunId,\n        ...message\n      });\n\n      this.raiseEvent(TaskEvent.SENT, taskRunId);\n    });\n  };\n}\n","var __WEBPACK_NAMESPACE_OBJECT__ = require(\"react\");","import * as React from 'react';\n\nimport { RunTaskAPI, TaskFuncContext, TaskOptions } from '../types';\nimport { TaskEvent } from '../types';\nimport { Task } from '../task';\n\nexport type UseTaskStatus = {\n  isRunning: boolean\n  queueLength: number\n  isCompleted: boolean\n}\n\nexport const useTask = <Params extends any[], Result = any, EventsList extends string = any>(\n  func: (\n    this: TaskFuncContext<Result, EventsList>, ...args: Params) => Result | Promise<Result> | Generator<any> | void,\n  options: TaskOptions = {},\n  leftArgs: any[] = []\n): [Task<Params, Result, EventsList> | null, UseTaskStatus] => {\n\n  const [taskIsRunning, setTaskIsRunning] = React.useState<boolean>(null);\n  const [taskQueueLength, setTaskQueueLength] = React.useState<number>(0);\n  const [taskIsCompleted, setTaskIsCompleted] = React.useState<boolean>(false);\n  const [task, setTask] = React.useState<Task<Params, Result, EventsList>>(null);\n\n  React.useEffect(() => {\n    const task = new Task<Params, Result, EventsList>(func, options);\n\n    task.whenEvent(TaskEvent.SENT, ({ queueLength }) => {\n      setTaskQueueLength(queueLength);\n    });\n\n    task.whenEvent(TaskEvent.STARTED, () => {\n      setTaskIsRunning(true);\n    });\n\n    task.whenEvent(TaskEvent.COMPLETED, ({ queueLength }) => {\n      setTaskIsRunning(false);\n      setTaskIsCompleted(true);\n      setTaskQueueLength(queueLength);\n    });\n\n    task.whenEvent(TaskEvent.NEXT, () => {\n      setTaskIsRunning(false);\n    });\n\n    task.whenEvent(TaskEvent.ERROR, () => {\n      setTaskIsRunning(false);\n    });\n\n    if (leftArgs.length) {\n      const clonedRunFunc: (...args: typeof leftArgs[number] | Params) =>\n        RunTaskAPI<Params, Result> = task.run.bind(task);\n\n      task.run = (...args) => clonedRunFunc(...leftArgs, ...args);\n    }\n\n    setTask(task);\n\n    return () => {\n      task.stop();\n    };\n  }, []);\n\n  return [\n    task,\n    {\n      isRunning: taskIsRunning,\n      queueLength: taskQueueLength,\n      isCompleted: taskIsCompleted\n    }\n  ];\n};\n","import type * as Brain from 'brain.js';\n\nimport {\n  TaskFuncContext,\n  TaskOptions\n} from '../types';\nimport { useTask } from './useTask';\nimport { isGeneratorFunc } from '../utils';\n\nexport const useBrainJsTask = <Params extends any[], Result = any, EventsList extends string = any>(\n  func: (\n    this: TaskFuncContext<Result>, brain: typeof Brain,\n    ...args: Params\n  ) => Result | Promise<Result> | Generator<any> | void,\n  brainJsVersion: string = 'latest',\n  options: TaskOptions = {}\n) => {\n  let taskFunc;\n\n  if (isGeneratorFunc(func)) {\n    taskFunc = function* (this, ...args) {\n      // brain variable it's the imported Brain.js library\n      // @ts-expect-error\n      yield* args[0].call(this, brain, ...args.slice(1));\n    };\n  } else {\n    taskFunc = function(this, ...args) {\n      // @ts-expect-error\n      return args[0].call(this, brain, ...args.slice(1));\n    };\n  }\n\n  return useTask<Params, Result, EventsList>(taskFunc, {\n    ...options,\n    deps: [\n      `https://unpkg.com/brain.js@${brainJsVersion}/dist/brain-browser.js`,\n      ...options.deps || []\n    ]\n  }, [func]);\n};\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","g","globalThis","this","Function","e","window","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","scriptUrl","importScripts","location","document","currentScript","src","scripts","getElementsByTagName","length","Error","replace","p","TaskEvent","Worker_fn","Worker","TaskWorker","Events","list","add","name","callback","once","id","push","remove","removeById","raise","result","reduceRight","_","count","keys","getCountCallbacks","clear","indexToRemove","findIndex","event","splice","genId","Math","random","toString","substr","DenormalizedObjectType","SyntaxError","CLONEABLE_OBJECTS","Date","RegExp","Blob","File","FileList","denormalizePostMessageData","data","FUNCTION","String","some","objClass","Array","isArray","map","item","reduce","Task","constructor","func","deps","events","init","whenEvent","eventName","whenNext","NEXT","run","args","stopped","taskRunId","sendMsgToWorker","ctx","whenSent","whenRunEvent","SENT","whenStarted","STARTED","whenCompleted","COMPLETED","whenError","ERROR","next","return","throw","stop","worker","terminate","queueLength","onmessage","message","tookTime","includes","raiseEvent","addEvent","Promise","resolve","reject","queueMicrotask","postMessage","require","useTask","options","leftArgs","taskIsRunning","setTaskIsRunning","taskQueueLength","setTaskQueueLength","taskIsCompleted","setTaskIsCompleted","task","setTask","clonedRunFunc","bind","isRunning","isCompleted","useBrainJsTask","brainJsVersion","taskFunc","isGeneratorFunc","brain","slice"],"sourceRoot":""}