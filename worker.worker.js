!function(){"use strict";class e extends Error{}class t extends SyntaxError{constructor(){super("The function syntax is erred")}}const n=(e,t,n=0)=>{for(let r=n+1;r<e.length;r++)if(!t.includes(e[r]))return{char:e[r],index:r};return{char:null,index:null}};var r;!function(e){e.FUNCTION="f"}(r||(r={}));const o=[Date,RegExp,Blob,File,FileList],s=(e,t)=>{if(e.length<2)return[];const[n,i]=e;return n===r.FUNCTION?t(i):(e=>null===e||o.some((t=>"number"==typeof e||"string"==typeof e||"boolean"==typeof e||e instanceof t)))(i)?i:Array.isArray(i)?i.map((e=>s(e,t))):Object.keys(i).reduce(((e,n)=>(e[n]=s(i[n],t),e)),{})};var i;!function(e){e.SENT="sent",e.STARTED="started",e.COMPLETED="completed",e.NEXT="next",e.ERROR="error"}(i||(i={})),Worker;const a=self,c={};let l,u=null,f=null;function d(e){return((e,{cache:r}={cache:null})=>{let o=(e=>(e=>{let t;for(let n=0;n<e.length;n++)t=Math.imul(31,t)+e.charCodeAt(n)|0;return t})(e).toString())(e);if(r&&r[o])return r[o];const{args:s,isGenerator:i}=(e=>{const n=e.indexOf("(")+1;if(!n)throw new t;const r=e.indexOf(")",n);if(-1===r)throw new t;let o=!1;const s=e.indexOf("*");return-1!==s&&(o=s<n),{isGenerator:o,args:e.substring(n,r)}})(e),a=(e=>{let r,o,s=!1;const i=(e=e.trim()).indexOf("function");if(i){r=e.indexOf("=>")+2;const t=n(e,[" "],r);if("("===t.char)s=!0,r=t.index+1,o=e.lastIndexOf(")");else{let t=n(e,[" "],r);"{"===t.char?(r=t.index+1,o=e.lastIndexOf("}")):(s=!0,o=e.length)}}else{if(r=e.indexOf("{",i)+1,!r)throw new t;o=e.lastIndexOf("}")}let a=e.substring(r,o).trim();return s&&a&&(a=` return ${a}`),a})(e),c=i?((e,t)=>(0,Object.getPrototypeOf((function*(){})).constructor)(e,t))(s,a):new Function(s,a);return r&&(r[o]=c),c})(e,{cache:c})}function T(e,{startTime:t=null,resolveEventName:n=i.COMPLETED}){e.then((e=>m(n,{startTime:t},e))).catch((e=>m(i.ERROR,{startTime:t},e)))}function m(e,{startTime:t=null}={},n=null){a.postMessage(Object.assign({eventName:e,result:n,taskRunId:l},t&&{tookTime:performance.now()-t}))}a.onmessage=t=>{const{data:n}=t;if(l=n.taskRunId,n.next||n.return||n.throw){if(!f)throw new e("Generator function is already finished or was not initiated");m(i.STARTED);const t=performance.now();let r;r=n.next?f.next(...n.args):n.return?f.return(n.args[0]):f.throw(n.args[0]),(r.done||n.throw)&&(f=null);const o=n.throw||r.done?i.COMPLETED:i.NEXT;return!n.throw&&r.value instanceof Promise?void r.value.then((e=>m(o,{startTime:t},e))).catch((e=>m(i.ERROR,{startTime:t},e))):void m(o,{startTime:t},r.value)}if(null===u&&(u=(n.deps||[]).length>0,u))try{importScripts(...n.deps)}catch(e){console.error(e)}const r=d(n.func),o=s(n.args||[],d),a={reply:(e,t)=>m(e,{startTime:c},t)};m(i.STARTED);const c=performance.now(),h=r.apply(a,o);if("GeneratorFunction"===r.constructor.name){const e=h.next(...o);return e.done||(f=h),e.value instanceof Promise?void T(e.value,{startTime:c,resolveEventName:e.done?i.COMPLETED:i.NEXT}):void m(e.done?i.COMPLETED:i.NEXT,{startTime:c},e.value)}h instanceof Promise?T(h,{startTime:c}):m(i.COMPLETED,{startTime:c},h)},a.onerror=e=>{m(i.ERROR,{},e)},(()=>a).bind(a)}();