{"version":3,"file":"worker.worker.js","mappings":"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","sources":["webpack://@tynik/web-workers/./src/errors.ts","webpack://@tynik/web-workers/./src/utils/string.ts","webpack://@tynik/web-workers/./src/utils/function.ts","webpack://@tynik/web-workers/./src/utils/transfer.ts","webpack://@tynik/web-workers/./src/types.ts","webpack://@tynik/web-workers/./src/worker.ts"],"sourcesContent":["\nexport class NextIterationError extends Error {}\n\nexport class FuncSyntaxError extends SyntaxError {\n  constructor() {\n    super('The function syntax is erred');\n  }\n}\n","export const genId = (length: number = 9): string =>\n  Math.random().toString(36).substr(2, length);\n\nexport const getStrHash = (str: string): number => {\n  let hash;\n  for (let i = 0; i < str.length; i++) {\n    hash = Math.imul(31, hash) + str.charCodeAt(i) | 0;\n  }\n  return hash;\n};\n\nexport const findNextChar = (str: string, skipChars: string[], from: number = 0): {\n  char: string\n  index: number\n} => {\n  for (let i = from + 1; i < str.length; i++) {\n    if (skipChars.includes(str[i])) {\n      continue;\n    }\n    return {\n      char: str[i],\n      index: i\n    };\n  }\n  return {\n    char: null,\n    index: null\n  };\n};\n","import {\n  FuncId,\n  TaskFunction,\n  TaskFunctionsCache\n} from '../types';\nimport { FuncSyntaxError } from '../errors';\nimport { getStrHash, findNextChar } from './string';\n\nexport const isFunction = (obj: any): boolean => typeof obj === 'function';\n\nexport const isGeneratorFunc = (func: TaskFunction): boolean =>\n  func.constructor.name === 'GeneratorFunction';\n\nexport const createGeneratorFuncFromStr = (args: string, funcCode: string): GeneratorFunction => {\n  const cls = Object.getPrototypeOf(function* () {}).constructor;\n  return cls(args, funcCode);\n};\n\nexport const generateTaskFuncId = (funcCode: string): FuncId =>\n  getStrHash(funcCode).toString();\n\nexport const getFuncArgsFromStr = (funcCode: string): {\n  args: string\n  isGenerator: boolean\n} => {\n  const startFuncArgsFrom = funcCode.indexOf('(') + 1;\n  if (!startFuncArgsFrom) {\n    throw new FuncSyntaxError();\n  }\n  const endFuncArgs = funcCode.indexOf(')', startFuncArgsFrom);\n  if (endFuncArgs === -1) {\n    throw new FuncSyntaxError();\n  }\n  let isGenerator = false;\n  const generatorMark = funcCode.indexOf('*');\n  if (generatorMark !== -1) {\n    isGenerator = generatorMark < startFuncArgsFrom;\n  }\n\n  return {\n    isGenerator,\n    args: funcCode.substring(startFuncArgsFrom, endFuncArgs)\n  };\n};\n\nexport const getFuncBodyFromStr = (funcCode: string): string => {\n  funcCode = funcCode.trim();\n\n  let funcBodyStart;\n  let funcBodyEnd;\n  let isInlineArrowFunc = false;\n\n  const isTraditionalFunc = funcCode.indexOf('function');\n  if (!isTraditionalFunc) {\n    funcBodyStart = funcCode.indexOf('{', isTraditionalFunc) + 1;\n    if (!funcBodyStart) {\n      throw new FuncSyntaxError();\n    }\n    funcBodyEnd = funcCode.lastIndexOf('}');\n\n  } else {\n    // arrow function\n    funcBodyStart = funcCode.indexOf('=>') + 2;\n\n    const isInlineArrowFuncWithObjReturning = findNextChar(funcCode, [' '], funcBodyStart);\n    // try to find \"(\" as the first char after \"=>\" to know that a function with object returning\n    if (isInlineArrowFuncWithObjReturning.char === '(') {\n      isInlineArrowFunc = true;\n      funcBodyStart = isInlineArrowFuncWithObjReturning.index + 1;\n      funcBodyEnd = funcCode.lastIndexOf(')');\n\n    } else {\n      let nextChar = findNextChar(funcCode, [' '], funcBodyStart);\n      if (nextChar.char === '{') {\n        funcBodyStart = nextChar.index + 1;\n        funcBodyEnd = funcCode.lastIndexOf('}');\n      } else {\n        isInlineArrowFunc = true;\n        funcBodyEnd = funcCode.length;\n      }\n    }\n  }\n\n  let body = funcCode.substring(funcBodyStart, funcBodyEnd).trim();\n\n  if (isInlineArrowFunc && body) {\n    body = ` return ${body}`;\n  }\n  return body;\n};\n\nexport type CreateFuncFromStrOptions = {\n  cache?: TaskFunctionsCache\n}\n\nexport const createFuncFromStr = (\n  funcCode: string,\n  { cache }: CreateFuncFromStrOptions = { cache: null }\n): TaskFunction => {\n\n  let taskFuncId = generateTaskFuncId(funcCode);\n  if (cache && cache[taskFuncId]) {\n    return cache[taskFuncId];\n  }\n  const {\n    args: funcArgs,\n    isGenerator: isGeneratorFunc\n  } = getFuncArgsFromStr(funcCode);\n\n  const funcBody = getFuncBodyFromStr(funcCode);\n\n  const func: TaskFunction = isGeneratorFunc\n    ? createGeneratorFuncFromStr(funcArgs, funcBody)\n    : new Function(funcArgs, funcBody);\n\n  if (cache) {\n    cache[taskFuncId] = func;\n  }\n  return func;\n};\n","import { TaskFunction } from '../types';\nimport { isFunction } from './function';\n\nexport enum DenormalizedObjectType {\n  FUNCTION = 'f'\n}\n\nexport const CLONEABLE_OBJECTS = [\n  Date,\n  RegExp,\n  Blob,\n  File,\n  FileList\n  // ArrayBuffer,\n  // Int8Array,\n  // Uint8Array,\n  // Uint8ClampedArray,\n  // Int16Array,\n  // Uint16Array,\n  // Int32Array,\n  // Uint32Array,\n  // Float32Array,\n  // Float64Array,\n  // DataView\n  // ImageBitmap,\n  // ImageData,\n  // Map,\n  // Set\n];\n\nexport const ifCloneableObject = (obj: any) =>\n  obj === null\n  || CLONEABLE_OBJECTS.some(objClass =>\n    typeof obj === 'number'\n    || typeof obj === 'string'\n    || typeof obj === 'boolean'\n    || obj instanceof objClass\n  );\n\nexport const denormalizePostMessageData = (data: any): any => {\n  if (isFunction(data)) {\n    return [DenormalizedObjectType.FUNCTION, String(data)];\n  }\n\n  if (ifCloneableObject(data)) {\n    return [null, data];\n  }\n\n  if (Array.isArray(data)) {\n    return [\n      null,\n      data.map(item => denormalizePostMessageData(item))\n    ];\n  }\n\n  return [\n    null,\n    Object.keys(data).reduce(\n      (result, key) => {\n        result[key] = denormalizePostMessageData(data[key]);\n        return result;\n      }, {})\n  ];\n};\n\nexport const normalizePostMessageData = (\n  args: any[],\n  normalizeFuncHandler: (obj: string) => TaskFunction\n): any => {\n  if (args.length < 2) {\n    return [];\n  }\n  const [primitiveType, obj] = args;\n\n  if (primitiveType === DenormalizedObjectType.FUNCTION) {\n    return normalizeFuncHandler(obj);\n  }\n\n  if (ifCloneableObject(obj)) {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map(item => normalizePostMessageData(item, normalizeFuncHandler));\n  }\n\n  return Object.keys(obj).reduce((result, key) => {\n    result[key] = normalizePostMessageData(obj[key], normalizeFuncHandler);\n    return result;\n  }, {});\n};\n","import { EventCallback, EventAPI } from './events';\n\n// <--------- THESE TYPES ARE DUPLICATED WITH worker-loader.d.ts --------->\nexport type TaskRunId = string\n\nexport type FuncTaskMessage = {\n  func: string\n  args: any[]\n  deps: string[]\n}\n\nexport type GeneratorNextTaskMessage = {\n  next: boolean\n  args: any[]\n}\n\nexport type GeneratorReturnTaskMessage = {\n  return: boolean\n  args: [any]\n}\n\nexport type GeneratorThrowTaskMessage = {\n  throw: boolean\n  args: [any]\n}\n\nexport type TaskMessage = FuncTaskMessage\n  | GeneratorNextTaskMessage\n  | GeneratorReturnTaskMessage\n  | GeneratorThrowTaskMessage\n\nexport type TaskReplyMessage<Result = any, EventsList extends string = any> = {\n  taskRunId: TaskRunId\n  eventName: EventsList\n  result: Result\n  tookTime?: number\n}\n// </--------- THESE TYPES ARE DUPLICATED WITH worker-loader.d.ts --------->\n\nexport type FuncId = string;\n\nexport type TaskFunction = Function\n  | GeneratorFunction\n  | AsyncGeneratorFunction;\n\nexport type TaskFunctionResult = Generator | any\n\nexport type TaskFunctionsCache = Record<FuncId, TaskFunction>\n\nexport enum TaskEvent {\n  SENT = 'sent',\n  STARTED = 'started',\n  COMPLETED = 'completed',\n  NEXT = 'next',\n  ERROR = 'error'\n}\n\nexport type Meta = {\n  taskRunId: TaskRunId\n  queueLength: number\n  tookTime?: number\n}\n\nexport type TaskOptions = {\n  deps?: string[];\n}\n\nexport interface RunTaskAPI<Params extends any[], Result = any, EventsList extends string = any> {\n  whenSent: Promise<Meta>;\n  whenStarted: Promise<Meta>;\n  whenCompleted: Promise<{ result: Result } & Meta>;\n  whenError: Promise<{ result: string } & Meta>;\n  next: (...args: Params) => Promise<{ result: Result } & Meta>;\n  return: (value?: any) => void;\n  throw: (e?: any) => void;\n}\n\nexport interface TaskFuncContext<Result = any, EventsList extends string = any> {\n  reply: (eventName: string | TaskEvent, result: Result) => void;\n}\n\ninterface TaskWorkerI {\n  postMessage(message: TaskReplyMessage, transfer: Transferable[]): void;\n\n  postMessage(message: TaskReplyMessage, options?: StructuredSerializeOptions): void;\n}\n\nexport type TaskMessageEventData = {\n  taskRunId: TaskRunId\n} & (\n  FuncTaskMessage\n  & GeneratorNextTaskMessage\n  & GeneratorReturnTaskMessage\n  & GeneratorThrowTaskMessage\n);\n\nexport class TaskWorker extends Worker implements TaskWorkerI {\n  onmessage: ((this: TaskWorker, ev: MessageEvent<TaskMessageEventData>) => any) | null;\n  onmessageerror: ((this: TaskWorker, ev: MessageEvent<TaskMessageEventData>) => any) | null;\n}\n","import {\n  isGeneratorFunc,\n  normalizePostMessageData,\n  createFuncFromStr\n} from './utils';\nimport {\n  TaskFunctionsCache,\n  TaskFunctionResult,\n  TaskWorker,\n  TaskEvent\n} from './types';\nimport { NextIterationError } from './errors';\nimport { TaskFunction } from './types';\n\nconst ctx: TaskWorker = self as any;\n\nconst _TASK_FUNCTIONS_CACHE: TaskFunctionsCache = {};\n\nlet _taskRunId: TaskRunId;\nlet _depsAreAlreadyImported: boolean = null;\nlet _currentGeneratorTask: Generator = null;\n\nctx.onmessage = (message) => {\n  const { data } = message;\n\n  _taskRunId = data.taskRunId;\n\n  if (data.next || data.return || data.throw) {\n    if (!_currentGeneratorTask) {\n      throw new NextIterationError('Generator function is already finished or was not initiated');\n    }\n    _reply(TaskEvent.STARTED);\n\n    const startTime = performance.now();\n\n    let iterationResult;\n    if (data.next) {\n      iterationResult = _currentGeneratorTask.next(...data.args as any);\n\n    } else if (data.return) {\n      iterationResult = _currentGeneratorTask.return(data.args[0]);\n\n    } else {\n      iterationResult = _currentGeneratorTask.throw(data.args[0]);\n    }\n\n    if (iterationResult.done || data.throw) {\n      // clear generator task and after that generator cannot be accessed\n      _currentGeneratorTask = null;\n    }\n\n    const replyEventName = data.throw || iterationResult.done\n      ? TaskEvent.COMPLETED\n      : TaskEvent.NEXT;\n\n    if (!data.throw && iterationResult.value instanceof Promise) {\n      iterationResult.value\n        .then((result) => _reply(replyEventName, { startTime }, result))\n        .catch((reason) => _reply(TaskEvent.ERROR, { startTime }, reason));\n\n      return;\n    }\n\n    _reply(replyEventName, { startTime }, iterationResult.value);\n    return;\n  }\n\n  // import scripts only the first time doesn't need to import them each time\n  if (_depsAreAlreadyImported === null) {\n    _depsAreAlreadyImported = (\n      data.deps || []\n    ).length > 0;\n\n    if (_depsAreAlreadyImported) {\n      try {\n        importScripts(...data.deps);\n      } catch (e) {\n        console.error(e);\n      }\n    }\n  }\n\n  const taskFunc = _createFunction(data.func);\n\n  const taskFuncArgs = normalizePostMessageData(\n    data.args || [],\n    _createFunction\n  );\n\n  // propagate that context for each task function\n  const taskFuncContext = {\n    reply: (eventName: string, result: any) =>\n      _reply(eventName, { startTime }, result)\n  };\n\n  _reply(TaskEvent.STARTED);\n\n  // to measure how long function is executed\n  const startTime: number = performance.now();\n\n  const taskFuncResult: TaskFunctionResult = taskFunc.apply(taskFuncContext, taskFuncArgs);\n\n  if (isGeneratorFunc(taskFunc)) {\n    const iterationResult: IteratorResult<any> = taskFuncResult.next(...taskFuncArgs);\n    if (!iterationResult.done) {\n      _currentGeneratorTask = taskFuncResult;\n    }\n    if (iterationResult.value instanceof Promise) {\n      _handlePromiseFunc(iterationResult.value, {\n        startTime,\n        resolveEventName: iterationResult.done\n          ? TaskEvent.COMPLETED\n          : TaskEvent.NEXT\n      });\n      return;\n    }\n    _reply(\n      iterationResult.done\n        ? TaskEvent.COMPLETED\n        : TaskEvent.NEXT,\n      { startTime },\n      iterationResult.value\n    );\n    return;\n  }\n\n  if (taskFuncResult instanceof Promise) {\n    _handlePromiseFunc(taskFuncResult, { startTime });\n    return;\n  }\n  _reply(TaskEvent.COMPLETED, { startTime }, taskFuncResult);\n};\n\nctx.onerror = (e) => {\n  _reply(TaskEvent.ERROR, {}, e);\n};\n\nfunction _createFunction(funcCode: string): TaskFunction {\n  return createFuncFromStr(funcCode, { cache: _TASK_FUNCTIONS_CACHE });\n}\n\nfunction _handlePromiseFunc(\n  promise: Promise<any>,\n  {\n    startTime = null,\n    resolveEventName = TaskEvent.COMPLETED\n  }: {\n    startTime: number,\n    resolveEventName?: TaskEvent.COMPLETED | TaskEvent.NEXT\n  }\n) {\n  promise\n    .then((result) => _reply(resolveEventName, { startTime }, result))\n    .catch((reason) => _reply(TaskEvent.ERROR, { startTime }, reason));\n}\n\nfunction _reply(eventName: string, { startTime = null } = {}, result: any = null) {\n  ctx.postMessage({\n    eventName,\n    result,\n    taskRunId: _taskRunId,\n    ...(\n      startTime && {\n        tookTime: performance.now() - startTime\n      }\n    )\n  });\n}\n\n// for testing\nexport default (\n  () => ctx\n).bind(ctx);\n"],"names":["NextIterationError","Error","FuncSyntaxError","SyntaxError","constructor","super","findNextChar","str","skipChars","from","i","length","includes","char","index","createFuncFromStr","funcCode","cache","taskFuncId","hash","Math","imul","charCodeAt","getStrHash","toString","generateTaskFuncId","args","funcArgs","isGenerator","isGeneratorFunc","startFuncArgsFrom","indexOf","endFuncArgs","generatorMark","substring","getFuncArgsFromStr","funcBody","funcBodyStart","funcBodyEnd","isInlineArrowFunc","isTraditionalFunc","trim","isInlineArrowFuncWithObjReturning","lastIndexOf","nextChar","body","getFuncBodyFromStr","func","cls","Object","getPrototypeOf","createGeneratorFuncFromStr","Function","DenormalizedObjectType","CLONEABLE_OBJECTS","Date","RegExp","Blob","File","FileList","normalizePostMessageData","normalizeFuncHandler","primitiveType","obj","FUNCTION","some","objClass","ifCloneableObject","Array","isArray","map","item","keys","reduce","result","key","TaskEvent","Worker","ctx","self","_TASK_FUNCTIONS_CACHE","_taskRunId","_depsAreAlreadyImported","_currentGeneratorTask","_createFunction","_handlePromiseFunc","promise","startTime","resolveEventName","COMPLETED","then","_reply","catch","reason","ERROR","eventName","postMessage","taskRunId","tookTime","performance","now","onmessage","message","data","next","return","throw","STARTED","iterationResult","done","replyEventName","NEXT","value","Promise","deps","importScripts","e","console","error","taskFunc","taskFuncArgs","taskFuncContext","reply","taskFuncResult","apply","name","onerror","bind"],"sourceRoot":""}